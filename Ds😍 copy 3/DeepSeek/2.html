<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ball Physics</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000; 
        }
        canvas {
            display: block;
        }
        button {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: Arial;
        }
    </style>
</head>
<body>
    <button id="addBall">Add Ball</button>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        const balls = [];
        const colors = ['#ff6b6b', '#48dbfb', '#1dd1a1', '#feca57', '#5f27cd'];
        
        class Ball {
            constructor(x, y) {
                this.x = x || Math.random() * canvas.width;
                this.y = y || Math.random() * canvas.height;
                this.radius = Math.random() * 30 + 10;
                this.dx = (Math.random() - 0.5) * 10;
                this.dy = (Math.random() - 0.5) * 10;
                this.color = colors[Math.floor(Math.random() * colors.length)];
            }
            
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.stroke();
            }
            
            update() {
                // Wall collision
                if (this.x + this.radius > canvas.width || this.x - this.radius < 0) {
                    this.dx = -this.dx;
                }
                if (this.y + this.radius > canvas.height || this.y - this.radius < 0) {
                    this.dy = -this.dy;
                }
                
                // Apply friction
                this.dx *= 0.99;
                this.dy *= 0.99;
                
                // Apply gravity
                this.dy += 0.1;
                
                this.x += this.dx;
                this.y += this.dy;
            }
        }
        
        // Ball-to-ball collision
        function checkCollisions() {
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const ball1 = balls[i];
                    const ball2 = balls[j];
                    
                    const dx = ball2.x - ball1.x;
                    const dy = ball2.y - ball1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < ball1.radius + ball2.radius) {
                        // Collision detected
                        const angle = Math.atan2(dy, dx);
                        const sin = Math.sin(angle);
                        const cos = Math.cos(angle);
                        
                        // Rotate velocities
                        const vx1 = ball1.dx * cos + ball1.dy * sin;
                        const vy1 = ball1.dy * cos - ball1.dx * sin;
                        const vx2 = ball2.dx * cos + ball2.dy * sin;
                        const vy2 = ball2.dy * cos - ball2.dx * sin;
                        
                        // Final velocities after collision (conservation of momentum)
                        const finalVx1 = ((ball1.radius - ball2.radius) * vx1 + 2 * ball2.radius * vx2) / (ball1.radius + ball2.radius);
                        const finalVx2 = ((ball2.radius - ball1.radius) * vx2 + 2 * ball1.radius * vx1) / (ball1.radius + ball2.radius);
                        
                        // Update velocities
                        ball1.dx = finalVx1 * cos - vy1 * sin;
                        ball1.dy = vy1 * cos + finalVx1 * sin;
                        ball2.dx = finalVx2 * cos - vy2 * sin;
                        ball2.dy = vy2 * cos + finalVx2 * sin;
                        
                        // Prevent sticking
                        const overlap = ball1.radius + ball2.radius - distance;
                        ball1.x -= overlap * Math.cos(angle) * 0.5;
                        ball1.y -= overlap * Math.sin(angle) * 0.5;
                        ball2.x += overlap * Math.cos(angle) * 0.5;
                        ball2.y += overlap * Math.sin(angle) * 0.5;
                    }
                }
            }
        }
        
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            balls.forEach(ball => {
                ball.draw();
                ball.update();
            });
            
            checkCollisions();
            requestAnimationFrame(animate);
        }
        
        // Add initial balls
        for (let i = 0; i < 5; i++) {
            balls.push(new Ball());
        }
        
        // Add ball on click
        document.getElementById('addBall').addEventListener('click', () => {
            balls.push(new Ball());
        });
        
        // Add ball on canvas click
        canvas.addEventListener('click', (e) => {
            balls.push(new Ball(e.clientX, e.clientY));
        });
        
        animate();
    </script>
</body>
</html>