<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Sand Simulation</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
    }
    canvas {
      display: block;
      background: #111;
    }
    .controls {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
      font-family: Arial, sans-serif;
    }
    .controls button {
      padding: 10px 18px;
      margin-right: 8px;
      background: #00cec9;
      border: none;
      border-radius: 6px;
      color: #fff;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    .controls button:hover {
      background: #0984e3;
    }
  </style>
</head>
<body>

<div class="controls">
  <button id="sand">Sand</button>
  <button id="water">Water</button>
  <button id="clear">Clear</button>
</div>
<canvas id="sandbox"></canvas>

<script>
  const canvas = document.getElementById("sandbox");
  const ctx = canvas.getContext("2d");

  // Resize canvas
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resizeCanvas();
  window.addEventListener("resize", resizeCanvas);

  const CELL_SIZE = 4;
  let COLS = Math.floor(canvas.width / CELL_SIZE);
  let ROWS = Math.floor(canvas.height / CELL_SIZE);

  let grid = Array.from({ length: COLS }, () => Array(ROWS).fill(0));
  let currentMaterial = 1; // 1 = Sand, 2 = Water

  document.getElementById("sand").onclick = () => currentMaterial = 1;
  document.getElementById("water").onclick = () => currentMaterial = 2;
  document.getElementById("clear").onclick = () => {
    grid = Array.from({ length: COLS }, () => Array(ROWS).fill(0));
  };

  const COLORS = {
    1: "#f1c40f", // Sand
    2: "#3498db", // Water
  };

  // Draw the grid
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let x = 0; x < COLS; x++) {
      for (let y = 0; y < ROWS; y++) {
        const value = grid[x][y];
        if (value > 0) {
          ctx.fillStyle = COLORS[value];
          ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
      }
    }
  }

  // Physics Update
  function update() {
    for (let y = ROWS - 2; y >= 0; y--) {
      for (let x = 0; x < COLS; x++) {
        const cell = grid[x][y];

        if (cell === 1) { // Sand
          if (grid[x]?.[y + 1] === 0) {
            grid[x][y] = 0;
            grid[x][y + 1] = 1;
          } else {
            const dir = Math.random() < 0.5 ? -1 : 1;
            if (grid[x + dir]?.[y + 1] === 0) {
              grid[x][y] = 0;
              grid[x + dir][y + 1] = 1;
            }
          }
        }

        else if (cell === 2) { // Water
          if (grid[x]?.[y + 1] === 0) {
            grid[x][y] = 0;
            grid[x][y + 1] = 2;
          } else {
            const dirs = [-1, 1];
            for (let d of dirs.sort(() => Math.random() - 0.5)) {
              if (grid[x + d]?.[y] === 0) {
                grid[x][y] = 0;
                grid[x + d][y] = 2;
                break;
              }
            }
          }
        }
      }
    }
  }

  // Drawing with mouse
  let isDrawing = false;
  const BRUSH_SIZE = 3;

  canvas.addEventListener("mousedown", () => isDrawing = true);
  canvas.addEventListener("mouseup", () => isDrawing = false);
  canvas.addEventListener("mouseleave", () => isDrawing = false);
  canvas.addEventListener("mousemove", (e) => {
    if (!isDrawing) return;

    const x = Math.floor(e.clientX / CELL_SIZE);
    const y = Math.floor(e.clientY / CELL_SIZE);

    for (let i = -BRUSH_SIZE; i <= BRUSH_SIZE; i++) {
      for (let j = -BRUSH_SIZE; j <= BRUSH_SIZE; j++) {
        const nx = x + i, ny = y + j;
        if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
          if (Math.random() > 0.2) {
            grid[nx][ny] = currentMaterial;
          }
        }
      }
    }
  });

  function animate() {
    update();
    draw();
    requestAnimationFrame(animate);
  }

  animate();
</script>

</body>
</html>

<!--ðŸ“… Day 31: Gravity Sand Simulation (Canvas + Pixel Manipulation)
Title: "Satisfying Sand Physics Simulation! ðŸ–ï¸ #JavaScript"
ðŸ“Œ Description:
"Create a mesmerizing sand/water physics simulation with JavaScript! Perfect for creative coding. Want more simulations? Subscribe! #JavaScript #CreativeCoding"

ðŸ·ï¸ Tags:
#Physics #Simulation #JavaScript #CreativeCoding #GameDev-->

